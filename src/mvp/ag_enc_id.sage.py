

# This file was *autogenerated* from the file src/mvp/ag_enc_id.sage
from sage.all_cmdline import *   # import sage library

_sage_const_7 = Integer(7); _sage_const_8 = Integer(8); _sage_const_16 = Integer(16); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_123456787654321 = Integer(123456787654321); _sage_const_10 = Integer(10); _sage_const_4 = Integer(4)# there must be Setup, KeyGen, Extract, Encrypt, Decrypt functions of AgEncID protocol
import time
import hashlib

import numpy as np

load('src/mvp/bn381.sage')

def Hash(number: int, p: int) -> int:
    '''return hash of number modulo p'''
    number_bytes = number.to_bytes((number.bit_length() + _sage_const_7 ) // _sage_const_8 , byteorder='big')

    sha3_384_hash = hashlib.sha3_384(number_bytes).hexdigest()

    return int(sha3_384_hash, _sage_const_16 ) % p
    
def Setup(l: int, m: int):
    pairing = BN381Pairing()
    
    gamma = randint(_sage_const_1 , pairing.r)

    #TODO: Change points G and H to random generators
    G = pairing.P1
    H = pairing.P2

    msk = (G, gamma)

    # Compute pk
    pk = [gamma * G, pairing.e(G, H), H] # pk = [w, v, H]
    temp = H
    for i in range(m): # Append h^(gamma^j) to pk, for j in [1, m]
        temp = gamma * temp
        pk.append(temp)

    return msk, pk, pairing

def Extract(msk, ID: int, pairing):
    G, gamma = msk

    sk_ID = pow(gamma + Hash(ID, pairing.r), -_sage_const_1 , pairing.r) * G

    return sk_ID

def Encrypt(S: list[int], pk, pairing):
    k = randint(_sage_const_2 , pairing.r)

    C1 = (pairing.r - k) * pk[_sage_const_0 ]

    # Compute C2 using polynomial where gamma^i is a random variable x^i
    R = PolynomialRing(GF(pairing.r), "x")
    mul_poly = R(_sage_const_1 )
    for ID in S:
        mul_poly *= R(x + Hash(ID, pairing.r))
    
    mul_poly = R(k) * mul_poly

    # Compute C2 using coefficients in polynomial
    C2 = _sage_const_0 
    for power, coeff in mul_poly.monomial_coefficients().items():
        C2 += coeff * pk[power + _sage_const_2 ]

    K = k * pk[_sage_const_1 ]

    return (C1, C2), K

def Decrypt(S, ID, sk_ID, Hdr, pk, pairing):
    C1, C2 = Hdr
    
    S_i = S.copy() # for beter readability remove ID from set S
    S_i.remove(ID)
    
    exponent = _sage_const_1 
    for ID_i in S_i:
        exponent = (exponent * Hash(ID_i, pairing.r)) % pairing.r
    exponent = pow(exponent, -_sage_const_1 , pairing.r)

    # Compute H^(p_iS) using polynomial p_iS_polly
    R = PolynomialRing(GF(pairing.r), "x")
    p_iS_polly = R(_sage_const_1 )
    for ID_i in S_i:
        p_iS_polly *= R(x + Hash(ID_i, pairing.r))
    
    # remove product of Hash(ID, pairing.r)
    prod = R(_sage_const_1 )
    for ID_i in S_i:
        prod *= Hash(ID_i, pairing.r)
    
    p_iS_polly -= prod
    
    print(p_iS_polly)
    print("gg")

    # Compute H^(p_iS) using coefficients in polynomial p_iS_polly
    Hp_iS = _sage_const_0 
    for power, coeff in p_iS_polly.monomial_coefficients().items():
        Hp_iS += coeff * pk[power + _sage_const_1 ] # divider by gamma, so index is smaller

    K = pow(pairing.e(C1, Hp_iS) * pairing.e(sk_ID, C2), exponent)

    return K

def time_evalation(n: int):
    time_start = time.time()
    pp = Setup(l=None, n=n)
    time_finish = time.time()
    print(f"Setup time: {time_finish - time_start:0.3f} s.")

    time_start = time.time()
    msk, v, keyset = KeyGen(pp)
    time_finish = time.time()
    print(f"KeyGen time: {time_finish - time_start:0.3f} s.")

    S = [i for i in range(_sage_const_2 , pp.n)]
    m = _sage_const_123456787654321 
    time_start = time.time()
    C = Encrypt(pp, S, v, m)
    time_finish = time.time()
    print(f"Encrypt time: {time_finish - time_start:0.3f} s.")

    i = _sage_const_10 
    time_start = time.time()
    m_ = Decrypt(pp, S, i, keyset[i], C)
    time_finish = time.time()
    print(f"Decrypt time: {time_finish - time_start:0.3f} s.")

    print("m: ", m)
    print("m':", m_)

def main(m: int):
    msk, pk, pairing = Setup(l=None, m=m)

    ID = _sage_const_4 
    sk_ID = Extract(msk=msk, ID=ID, pairing=pairing)

    S = [i for i in range(m)]
    # S = [2, 4, 9, 11, 56]
    Hdr, K = Encrypt(S, pk, pairing)

    K_ = Decrypt(S=S, ID=ID, sk_ID=sk_ID, Hdr=Hdr, pk=pk, pairing=pairing)

    print(K)
    print("")
    print(K_)
    print("")
    print("K == K_:", K == K_)

if __name__ == "__main__":
    main(_sage_const_10 )
    # time_evalation(100)

