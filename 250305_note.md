# Summary

Our goal is to achieve forward secrecy and post-compromise secrecy in identity-based encryption. For that reason we have tried to adopt construction [Identity-Based Broadcast Encryption with Constant Size Ciphertexts and Private Keys](https://link.springer.com/content/pdf/10.1007/978-3-540-76900-2_12.pdf) by Cecile Delerablee. We believe that solving this problem will be useful in development of a private group messeging system.

## Problems

We faced with several problems while researching that scheme. Firstly, we concluded that i-th user must take a part in computation of his secret key $sk_{ID_i}$ using some private value $r_{i}$:
- Our first na—óve approach was to take arbitrary r value and multiply $sk_{ID_i}$ by it: $sk_{ID_i}=g^{\frac{r_i}{\gamma+H(ID_i)}}$. For that reason we introduced accumulator value $R=h^{\prod_{i \in S} r_i}$ so that modify $C2=h^{k \prod_{i \in S}(\gamma+H(ID_i))}$ value. Unfortunatelly it is not feasible for a user to compute a polynomial in decryption stage without revealing $g^{1/\gamma}$ is public parameters which breaks the construction security completely.
- After that we come up with idea of splitting $sk_{ID}$ in 2 parts: first conventional Del7 part: $sk1_{ID_i}=g^{\frac{1}{\gamma+H(ID_i)}}$ and second ratcheting part $sk2_{ID_i}=g^{\frac{\alpha_i}{r_i(\epsilon+\gamma)}}$ where $r_i$ is short term secret and $\alpha_i$ is short term blinding factor that user deletes after he generates new $sk2_{ID}$ value. We introduced new ciphertexts $C_3 = g^{-\gamma k_2}, C_4 = h^{k_2 (\epsilon + \gamma )\gamma \prod_{i \in S} \frac{r_i}{alpha_i} }$ where $\epsilon$ is secret trusted party paramer as well as $\gamma$. This scheme seems better but also infeasible for computation as well as it requires computation of $v_{k_1+k_2}$, where $v_{k2}$ is not computable without revealing secret parameters.
- After that we have tried to split group generators $g \rightarrow g_1, g_2\quad h \rightarrow h_1, h_2$ where $e(g_1,h_2)=e(g_2,h_1)=1$ and compute $sk1_{ID_i}=g_1^{\frac{1}{\gamma+H(ID_i)}}, sk2_{ID_i}=g_2^{\frac{\alpha_i}{r_i(\epsilon+\gamma)}}$. One might notice that we need only 2 ciphertexts which contain products of $C_1 = C'_1 C'_3$ and $C_2 = C'_2 C'_4$ where rhs ciphertexts is taken from the previous approach. Secret keys need to be multiplied in the second pairing as well. There are 2 major approaches in this scheme: take exatly 1 $k$ value to produce $K=v_k$ but adversary simply does not need to compute the product $sk1 sk2$, indeed he needs only $sk1$ to compute valid key. One method to overcome this issue is to have only one $sk = sk1 sk2$ but actually there is a problem updating only $sk2$ as well as user needs to exponentiate the whole $sk$ value which obviously distorts $sk2$. The second approach is to take $K=v^{k_1+k_2}$, but this is also infeasible to compute as user does not posess his $\alpha$ value which he deleted on key update. When user instead stores his current $\alpha$ and $r$ values it is easy for an adversary to calculate $K$ by simply reducing $sk2$ by $r_i, \alpha_i$.

